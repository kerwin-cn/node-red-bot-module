'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const PublicKey_1 = require("../Core/Support/PublicKey");
const RSA_1 = __importDefault(require("../Core/Support/RSA"));
const Utils_1 = require("../Core/Support/Utils");
const Encryptor_1 = __importDefault(require("./Encryptor"));
class Utils {
    constructor(merchant) {
        this.merchant = merchant;
    }
    /**
     * 获取加密所用的平台证书
     * @returns
     */
    getPlatformCert() {
        return __awaiter(this, void 0, void 0, function* () {
            let certs = yield this.merchant.getPlatformCerts();
            if (!certs || Object.keys(certs).length === 0) {
                throw new Error('Fail to get platform certs');
            }
            return certs[Object.keys(certs)[0]];
        });
    }
    /**
     * 获取敏感信息加密机
     * @see https://pay.weixin.qq.com/docs/merchant/development/interface-rules/sensitive-data-encryption.html
     * @param platformCert PublicKey封装过的平台证书
     * @returns
     */
    getEncryptor() {
        return __awaiter(this, arguments, void 0, function* (platformCert = null) {
            if (!platformCert || !(platformCert instanceof PublicKey_1.PublicKey)) {
                platformCert = yield this.getPlatformCert();
            }
            let encryptor = new Encryptor_1.default;
            encryptor.setCerts(platformCert, this.merchant.getPrivateKey());
            return encryptor;
        });
    }
    /**
     * 创建签名（V3），并返回签名字符串
     * @param params 参数集合
     * @returns
     */
    createSignature(message) {
        let rsa = new RSA_1.default;
        rsa.setPrivateKey(this.merchant.getPrivateKey().toString());
        return rsa.sign(message);
    }
    /**
     * 创建签名（V2），并返回签名字符串
     * @param params 参数集合
     * @returns
     */
    createV2Signature(params) {
        let signString = '';
        let sparator = '';
        let keys = Object.keys(params);
        keys = keys.sort();
        for (let i = 0; i < keys.length; i++) {
            if (keys[i] == 'sign' || keys[i] == 'paySign' || typeof params[keys[i]] === undefined || params[keys[i]] === null)
                continue;
            signString += sparator + keys[i] + '=' + params[keys[i]];
            sparator = '&';
        }
        let key = this.merchant.getV2SecretKey();
        if (!key) {
            throw new Error('Missing V2 API key.');
        }
        signString += '&key=' + key;
        let sign = '';
        let type = params['signType'] ? (params['signType'] + '').toLowerCase() : 'md5';
        switch (type) {
            case 'sha1':
            case 'md5':
                sign = (0, Utils_1.createHash)(signString, type);
                break;
            case 'hmac-sha256':
            case 'hmac_sha256':
                type = type.replace(/^hmac[\-|_]/i, '');
                sign = (0, Utils_1.createHmac)(signString, key, type);
                break;
        }
        if (!sign) {
            throw new Error('Failed to sign the request.');
        }
        return (sign + '').toUpperCase();
    }
    /**
     * 构建JSBridge支付参数
     * @see [v3文档](https://pay.weixin.qq.com/wiki/doc/apiv3_partner/apis/chapter4_1_4.shtml)
     * @see [v2文档](https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=7_7&index=6)
     * @param prepayId 下单接口返回的prepay_id
     * @param appId 应用id
     * @param signType v3仅支持RSA，V2支持MD5、HMAC-SHA256
     * @returns
     */
    buildBridgeConfig(prepayId, appId, signType = 'RSA') {
        let params = {
            appId,
            timeStamp: '' + (0, Utils_1.getTimestamp)(),
            nonceStr: (0, Utils_1.randomString)(),
            package: 'prepay_id=' + prepayId,
            signType,
            paySign: '',
        };
        // v2
        if (signType != 'RSA') {
            params.paySign = this.createV2Signature(params);
        }
        // v3
        else {
            let message = `${params.appId}\n${params.timeStamp}\n${params.nonceStr}\n${params.package}\n`;
            params.paySign = this.createSignature(message);
        }
        return params;
    }
    /**
     * 构建JS-SDK支付参数
     * @see https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html#58
     * @param prepayId 下单接口返回的prepay_id
     * @param appId 应用id
     * @param signType v3仅支持RSA，V2支持MD5、HMAC-SHA256
     */
    buildSdkConfig(prepayId, appId, signType = 'RSA') {
        let config = this.buildBridgeConfig(prepayId, appId, signType);
        return {
            appId: config.appId,
            timestamp: config.timeStamp,
            nonceStr: config.nonceStr,
            package: config.package,
            signType: config.signType,
            paySign: config.paySign,
        };
    }
    /**
     * 构建小程序支付参数
     * @see https://developers.weixin.qq.com/miniprogram/dev/api/payment/wx.requestPayment.html
     * @param prepayId 下单接口返回的prepay_id
     * @param appId 应用id
     * @param signType v3仅支持RSA，V2支持MD5、HMAC-SHA256
     * @returns
     */
    buildMiniAppConfig(prepayId, appId, signType = 'RSA') {
        return this.buildBridgeConfig(prepayId, appId, signType);
    }
    /**
     * 构建App支付参数
     * @see https://pay.weixin.qq.com/wiki/doc/apiv3_partner/apis/chapter4_2_4.shtml
     * @param prepayId 下单接口返回的prepay_id
     * @param appId 应用id
     * @returns
     */
    buildAppConfig(prepayId, appId) {
        let params = {
            appId,
            partnerid: this.merchant.getMerchantId(),
            prepayid: prepayId,
            nonceStr: (0, Utils_1.randomString)(),
            timestamp: '' + (0, Utils_1.getTimestamp)(),
            package: 'Sign=WXPay',
            sign: '',
        };
        let message = `${params.appId}\n${params.timestamp}\n${params.nonceStr}\n${params.prepayid}\n`;
        params.sign = this.createSignature(message);
        return params;
    }
}
;
module.exports = Utils;
