'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.bufferToStream = exports.streamToBuffer = exports.createUserAgent = exports.buildXml = exports.parseXml = exports.singleItem = exports.strSnake = exports.strCamel = exports.strStudly = exports.strLcwords = exports.strUcwords = exports.rtrim = exports.ltrim = exports.trim = exports.applyMixins = exports.inArray = exports.isIp = exports.isIpv6 = exports.isIpv4 = exports.isFunction = exports.isObject = exports.isNumber = exports.isArray = exports.isString = exports.makeSignature = exports.randomString = exports.parseQueryString = exports.buildQueryString = exports.getTimestamp = exports.createFileHash = exports.createHmac = exports.createHash = void 0;
const crypto_1 = __importDefault(require("crypto"));
const qs_1 = __importDefault(require("qs"));
const xml2js_1 = __importDefault(require("xml2js"));
const stream_1 = __importDefault(require("stream"));
const fs_1 = __importDefault(require("fs"));
const axios_1 = __importDefault(require("axios"));
const createHash = function (str, type = 'sha1', target = 'hex') {
    return crypto_1.default.createHash(type).update(str).digest(target);
};
exports.createHash = createHash;
const createHmac = function (str, key, type = 'sha256', target = 'hex') {
    return crypto_1.default.createHmac(type, key).update(str).digest(target);
};
exports.createHmac = createHmac;
/**
 * 计算文件的哈希值
 * @param path 文件路径或文件可读流
 */
const createFileHash = function (path, type = 'sha1', target = 'hex') {
    return new Promise((reslove, reject) => {
        let stream;
        if ((0, exports.isString)(path)) {
            stream = fs_1.default.createReadStream(path);
        }
        else {
            stream = new stream_1.default.PassThrough();
            path.pipe(stream);
        }
        let md5sum = crypto_1.default.createHash(type);
        stream.on('data', function (chunk) {
            md5sum.update(chunk);
        });
        stream.on('end', function () {
            let str = md5sum.digest(target).toUpperCase();
            reslove(str);
        });
    });
};
exports.createFileHash = createFileHash;
const getTimestamp = function (datetime = null) {
    let time;
    try {
        time = ((0, exports.isString)(datetime) ? new Date(datetime) : new Date).getTime();
    }
    catch (e) {
        return 0;
    }
    return parseInt((time / 1000).toString());
};
exports.getTimestamp = getTimestamp;
const buildQueryString = function (data, options = {}) {
    return qs_1.default.stringify(data, options);
};
exports.buildQueryString = buildQueryString;
const parseQueryString = function (data, options = {}) {
    return qs_1.default.parse(data, options);
};
exports.parseQueryString = parseQueryString;
const randomString = function (len = 16) {
    let chars = 'ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678';
    let str = '';
    for (let i = 0; i < len; i++) {
        str += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return str;
};
exports.randomString = randomString;
const makeSignature = function (params, key = '', type = 'md5') {
    let paramsString = '';
    let sparator = '';
    let keys = Object.keys(params);
    keys = keys.sort();
    for (let i = 0; i < keys.length; i++) {
        if (keys[i] == 'sign' || !params[keys[i]])
            continue;
        paramsString += sparator + keys[i] + '=' + params[keys[i]];
        sparator = '&';
    }
    if (key) {
        paramsString += '&key=' + key;
    }
    let sign = '';
    type = type.toLowerCase();
    switch (type) {
        case 'sha1':
        case 'md5':
            sign = (0, exports.createHash)(paramsString, type);
            break;
        case 'hmac-sha256':
        case 'hmac_sha256':
            type = type.replace(/^hmac[\-|_]/i, '');
            sign = (0, exports.createHmac)(paramsString, key, type);
            break;
    }
    return (sign + '').toUpperCase();
};
exports.makeSignature = makeSignature;
const isString = function (data) {
    return Object.prototype.toString.call(data) == '[object String]';
};
exports.isString = isString;
const isArray = function (data) {
    return Object.prototype.toString.call(data) == '[object Array]';
};
exports.isArray = isArray;
const isNumber = function (data) {
    return Object.prototype.toString.call(data) == '[object Number]';
};
exports.isNumber = isNumber;
const isObject = function (data) {
    return Object.prototype.toString.call(data) == '[object Object]';
};
exports.isObject = isObject;
const isFunction = function (data) {
    return data && toString.call(data) == '[object Function]' || toString.call(data) == '[object AsyncFunction]';
};
exports.isFunction = isFunction;
const isIpv4 = function (ip) {
    if (!ip)
        return false;
    return /^(25[0-5]|2[0-4]\d|[0-1]\d{2}|[1-9]?\d)\.(25[0-5]|2[0-4]\d|[0-1]\d{2}|[1-9]?\d)\.(25[0-5]|2[0-4]\d|[0-1]\d{2}|[1-9]?\d)\.(25[0-5]|2[0-4]\d|[0-1]\d{2}|[1-9]?\d)$/.test(ip);
};
exports.isIpv4 = isIpv4;
const isIpv6 = function (ip) {
    if (!ip)
        return false;
    return /^([\\da-fA-F]{1,4}:){7}([\\da-fA-F]{1,4})$/.test(ip);
};
exports.isIpv6 = isIpv6;
const isIp = function (ip) {
    return (0, exports.isIpv4)(ip) || (0, exports.isIpv6)(ip);
};
exports.isIp = isIp;
const inArray = function (data, arr, strict = false) {
    if (!(0, exports.isArray)(arr))
        return strict ? data === arr : data == arr;
    if ((0, exports.isFunction)(arr.findIndex)) {
        return arr.findIndex((o) => { return strict ? o === data : o == data; }) > -1;
    }
    else {
        let flag = false;
        for (let i = 0; i < arr.length; i++) {
            if (strict ? data === arr[i] : data == arr[i]) {
                flag = true;
                break;
            }
        }
        return flag;
    }
};
exports.inArray = inArray;
/**
 * 类应用混入方法
 * @param derivedCtor 目标类
 * @param constructors 混入类列表
 */
const applyMixins = function (derivedCtor, constructors) {
    constructors.forEach((baseCtor) => {
        Object.getOwnPropertyNames(baseCtor.prototype).forEach((name) => {
            // 构造函数或目标类已有的方法，则以目标类的为准
            if (name === 'constructor' || typeof derivedCtor.prototype[name] !== 'undefined')
                return;
            Object.defineProperty(derivedCtor.prototype, name, Object.getOwnPropertyDescriptor(baseCtor.prototype, name) || Object.create(null));
        });
    });
};
exports.applyMixins = applyMixins;
/**
 * 去除字符串左右的符号
 * @param str 原字符串
 * @param chars 要去除的符号，正则字符串，默认空白符
 */
const trim = (str, chars = '\\s+') => {
    if (!str || !(0, exports.isString)(str))
        return '';
    return str.replace(new RegExp('^' + chars + '|' + chars + '$', 'gm'), '');
};
exports.trim = trim;
/**
 * 去除字符串左边的符号
 * @param str 原字符串
 * @param chars 要去除的符号，正则字符串，默认空白符
 */
const ltrim = (str, chars = '\\s+') => {
    if (!str || !(0, exports.isString)(str))
        return '';
    return str.replace(new RegExp('^' + chars, 'gm'), '');
};
exports.ltrim = ltrim;
/**
 * 去除字符串右边的符号
 * @param str 原字符串
 * @param chars 要去除的符号，正则字符串，默认空白符
 */
const rtrim = (str, chars = '\\s+') => {
    if (!str || !(0, exports.isString)(str))
        return '';
    return str.replace(new RegExp(chars + '$', 'gm'), '');
};
exports.rtrim = rtrim;
/**
 * 将单词首字母转成大写，'hello word' => 'Hello World'
 * @param str
 * @returns
 */
const strUcwords = function (str) {
    return str.replace(/\b[a-z]/gi, function (letter) {
        return letter.toUpperCase();
    });
};
exports.strUcwords = strUcwords;
/**
 * 将单词首字母转成小写，'Hello World' => 'hello word'
 * @param str
 * @returns
 */
const strLcwords = function (str) {
    return str.replace(/\b[a-z]/gi, function (letter) {
        return letter.toLowerCase();
    });
};
exports.strLcwords = strLcwords;
/**
 * 驼峰（首字母大写），'hello word' => 'HelloWorld'
 * @param value
 * @returns
 */
const strStudly = function (value) {
    return (0, exports.strUcwords)(value.replace(/[\-|\_]/gi, ' ')).replace(/\s/gi, '');
};
exports.strStudly = strStudly;
/**
 * 驼峰（首字母小写），'hello word' => 'helloWorld'
 * @param value
 * @returns
 */
const strCamel = function (value) {
    return (0, exports.strLcwords)((0, exports.strStudly)(value));
};
exports.strCamel = strCamel;
/**
 * 蛇形（下划线分隔，全小写），'helloWorld' => 'hello_world'
 * @param value
 * @returns
 */
const strSnake = function (value) {
    return value.replace(/([A-Z])/g, "_$1").toLowerCase().substring(1);
};
exports.strSnake = strSnake;
/**
 * 如果只有一个同名、同级节点，则不当作数组
 * @param obj
 * @returns
 */
const singleItem = function (obj) {
    if (typeof obj == 'object') {
        if (typeof obj.length != 'undefined') {
            if (obj.length == 1) {
                return (0, exports.singleItem)(obj[0]);
            }
            for (let i = 0; i < obj.length; i++) {
                obj[i] = (0, exports.singleItem)(obj[i]);
            }
            return obj;
        }
        else {
            for (let k in obj) {
                obj[k] = (0, exports.singleItem)(obj[k]);
            }
        }
    }
    return obj;
};
exports.singleItem = singleItem;
/**
 * 解析xml
 * @param xml
 * @returns
 */
const parseXml = function (xml) {
    return __awaiter(this, void 0, void 0, function* () {
        let res = yield xml2js_1.default.parseStringPromise(xml);
        // fix [Object: null prototype]
        res = JSON.parse(JSON.stringify(res));
        res = (0, exports.singleItem)(res);
        if (res['xml'])
            res = res['xml'];
        return res;
    });
};
exports.parseXml = parseXml;
/**
 * 构建xml
 * @param data 对象
 * @param rootName 根节点名，默认：'xml'
 * @returns
 */
const buildXml = function (data, rootName = 'xml') {
    let XmlBuilder = new xml2js_1.default.Builder({
        cdata: true,
        xmldec: null,
        rootName,
        renderOpts: {
            pretty: false,
            indent: '',
            newline: '',
        }
    });
    return XmlBuilder.buildObject(data).replace('<?xml version="1.0"?>', '');
};
exports.buildXml = buildXml;
/**
 * 创建UserAgent
 * @param appends 可选，附加的字符串列表
 * @returns
 */
const createUserAgent = function (appends = []) {
    let values = [];
    values.push(`node-easywechat/${require('../../../package.json').version}`);
    values.push(`axios/${axios_1.default.VERSION}`);
    values = values.concat(appends);
    return values.join(' ');
};
exports.createUserAgent = createUserAgent;
/**
 * 流转Buffer
 * @param stream 可读流
 */
const streamToBuffer = function (stream) {
    return new Promise((resolve, reject) => {
        let buffers = [];
        stream.on('error', reject);
        stream.on('data', data => buffers.push(data));
        stream.on('end', () => resolve(Buffer.concat(buffers)));
    });
};
exports.streamToBuffer = streamToBuffer;
/**
 * Buffer转流
 * @param buffer Buffer对象
 */
const bufferToStream = function (buffer) {
    let stream = new stream_1.default.Duplex();
    stream.push(buffer);
    stream.push(null);
    return stream;
};
exports.bufferToStream = bufferToStream;
